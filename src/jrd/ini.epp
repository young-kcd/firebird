/*
 *	PROGRAM:	JRD Access Method
 *	MODULE:		ini.epp
 *	DESCRIPTION:	Metadata initialization / population
 *
 * The contents of this file are subject to the Interbase Public
 * License Version 1.0 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy
 * of the License at http://www.Inprise.com/IPL.html
 *
 * Software distributed under the License is distributed on an
 * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * The Original Code was created by Inprise Corporation
 * and its predecessors. Portions created by Inprise Corporation are
 * Copyright (C) Inprise Corporation.
 *
 * All Rights Reserved.
 * Contributor(s): ______________________________________.
 */

#include "firebird.h"
#include <stdio.h>
#include <string.h>
#include "../jrd/flags.h"
#include "../jrd/jrd.h"
#include "../jrd/val.h"
#include "../jrd/ods.h"
#include "../jrd/btr.h"
#include "../jrd/ids.h"
#include "../jrd/intl.h"
#include "../jrd/tra.h"
#include "../jrd/trig.h"
#include "../jrd/intl.h"
#include "../jrd/dflt.h"
#include "../jrd/ini.h"
#include "../jrd/idx.h"
#include "../common/gdsassert.h"
#include "../dsql/dsql.h"
#include "../jrd/blb_proto.h"
#include "../jrd/cch_proto.h"
#include "../jrd/cmp_proto.h"
#include "../jrd/dfw_proto.h"
#include "../jrd/dpm_proto.h"
#include "../jrd/err_proto.h"
#include "../jrd/exe_proto.h"
#include "../yvalve/gds_proto.h"
#include "../jrd/idx_proto.h"
#include "../jrd/ini_proto.h"
#include "../jrd/jrd_proto.h"
#include "../jrd/met_proto.h"
#include "../jrd/tra_proto.h"
#include "../jrd/obj.h"
#include "../jrd/acl.h"
#include "../jrd/dyn.h"
#include "../jrd/irq.h"
#include "../jrd/IntlManager.h"
#include "../jrd/PreparedStatement.h"
#include "../jrd/constants.h"
#include "../jrd/grant_proto.h"
#include "../jrd/SystemPackages.h"

using namespace Firebird;
using namespace Jrd;

DATABASE DB = FILENAME "ODS.RDB";

namespace
{
	template <size_t N> void PAD(const char* string, TEXT (&field)[N])
	{
		jrd_vtof(string, (char*) field, sizeof(field));
	}

	template <size_t N> void PAD(const MetaName& name, TEXT (&field)[N])
	{
		jrd_vtof(name.c_str(), (char*) field, sizeof(field));
	}

	// This is the table used in defining triggers; note that
	// RDB$TRIGGER_0 was first changed to RDB$TRIGGER_7 to make it easier to
	// upgrade a database to support field-level grant.  It has since been
	// changed to RDB$TRIGGER_9 to handle SQL security on relations whose
	// name is > 27 characters

	const jrd_trg triggers[] =
	{
		{ "RDB$TRIGGER_1", (UCHAR) nam_user_privileges,
			RDB$TRIGGERS.RDB$TRIGGER_TYPE.PRE_MODIFY, sizeof(trigger3), trigger3,
			0, ODS_8_0 },
		{ "RDB$TRIGGER_8", (UCHAR) nam_user_privileges,
			RDB$TRIGGERS.RDB$TRIGGER_TYPE.PRE_ERASE, sizeof(trigger2), trigger2,
			0, ODS_8_0 },
		{ "RDB$TRIGGER_9", (UCHAR) nam_user_privileges,
			RDB$TRIGGERS.RDB$TRIGGER_TYPE.PRE_STORE, sizeof(trigger1), trigger1,
			0, ODS_8_0 },
		{ "RDB$TRIGGER_2", (UCHAR) nam_trgs,
			RDB$TRIGGERS.RDB$TRIGGER_TYPE.PRE_MODIFY, sizeof(trigger4), trigger4,
			0, ODS_8_0 },
		{ "RDB$TRIGGER_3", (UCHAR) nam_trgs,
			RDB$TRIGGERS.RDB$TRIGGER_TYPE.PRE_ERASE, sizeof(trigger4), trigger4,
			0, ODS_8_0 },
		{ "RDB$TRIGGER_26", (UCHAR) nam_rel_constr,
			RDB$TRIGGERS.RDB$TRIGGER_TYPE.PRE_STORE, sizeof(trigger26), trigger26,
			0, ODS_8_0 },
		{ "RDB$TRIGGER_25", (UCHAR) nam_rel_constr,
			RDB$TRIGGERS.RDB$TRIGGER_TYPE.PRE_MODIFY, sizeof(trigger25),
			trigger25, 0, ODS_8_0 },
		{ "RDB$TRIGGER_10", (UCHAR) nam_rel_constr,
			RDB$TRIGGERS.RDB$TRIGGER_TYPE.PRE_ERASE, sizeof(trigger10), trigger10,
			0, ODS_8_0 },
		{ "RDB$TRIGGER_11", (UCHAR) nam_rel_constr,
			RDB$TRIGGERS.RDB$TRIGGER_TYPE.POST_ERASE, sizeof(trigger11),
			trigger11, 0, ODS_8_0 },
		{ "RDB$TRIGGER_12", (UCHAR) nam_ref_constr,
			RDB$TRIGGERS.RDB$TRIGGER_TYPE.PRE_STORE, sizeof(trigger12), trigger12,
			0, ODS_8_0 },
		{ "RDB$TRIGGER_13", (UCHAR) nam_ref_constr,
			RDB$TRIGGERS.RDB$TRIGGER_TYPE.PRE_MODIFY, sizeof(trigger13),
			trigger13, 0, ODS_8_0 },
		{ "RDB$TRIGGER_14", (UCHAR) nam_chk_constr,
			RDB$TRIGGERS.RDB$TRIGGER_TYPE.PRE_MODIFY, sizeof(trigger14),
			trigger14, 0, ODS_8_0 },
		{ "RDB$TRIGGER_15", (UCHAR) nam_chk_constr,
			RDB$TRIGGERS.RDB$TRIGGER_TYPE.PRE_ERASE, sizeof(trigger15), trigger15,
			0, ODS_8_0 },
		{ "RDB$TRIGGER_16", (UCHAR) nam_chk_constr,
			RDB$TRIGGERS.RDB$TRIGGER_TYPE.POST_ERASE, sizeof(trigger16),
			trigger16, 0, ODS_8_0 },
		{ "RDB$TRIGGER_17", (UCHAR) nam_i_segments,
			RDB$TRIGGERS.RDB$TRIGGER_TYPE.PRE_ERASE, sizeof(trigger17), trigger17,
			0, ODS_8_0 },
		{ "RDB$TRIGGER_18", (UCHAR) nam_i_segments,
			RDB$TRIGGERS.RDB$TRIGGER_TYPE.PRE_MODIFY, sizeof(trigger18),
			trigger18, 0, ODS_8_0 },
		{ "RDB$TRIGGER_19", (UCHAR) nam_indices,
			RDB$TRIGGERS.RDB$TRIGGER_TYPE.PRE_ERASE, sizeof(trigger19), trigger19,
			0, ODS_8_0 },
		{ "RDB$TRIGGER_20", (UCHAR) nam_indices,
			RDB$TRIGGERS.RDB$TRIGGER_TYPE.PRE_MODIFY, sizeof(trigger20),
			trigger20, 0, ODS_8_0 },
		{ "RDB$TRIGGER_21", (UCHAR) nam_trgs,
			RDB$TRIGGERS.RDB$TRIGGER_TYPE.PRE_ERASE, sizeof(trigger21), trigger21,
			0, ODS_8_0 },
		{ "RDB$TRIGGER_22", (UCHAR) nam_trgs,
			RDB$TRIGGERS.RDB$TRIGGER_TYPE.PRE_MODIFY, sizeof(trigger22),
			trigger22, 0, ODS_8_0 },
		{ "RDB$TRIGGER_23", (UCHAR) nam_r_fields,
			RDB$TRIGGERS.RDB$TRIGGER_TYPE.PRE_ERASE, sizeof(trigger23), trigger23,
			0, ODS_8_0 },
		{ "RDB$TRIGGER_24", (UCHAR) nam_r_fields,
			RDB$TRIGGERS.RDB$TRIGGER_TYPE.PRE_MODIFY, sizeof(trigger24),
			trigger24, 0, ODS_8_0 },
		{ "RDB$TRIGGER_27", (UCHAR) nam_r_fields,
			RDB$TRIGGERS.RDB$TRIGGER_TYPE.POST_ERASE, sizeof(trigger27),
			trigger27, 0, ODS_8_0 },
		{ "RDB$TRIGGER_34", (UCHAR) nam_rel_constr,
			RDB$TRIGGERS.RDB$TRIGGER_TYPE.POST_ERASE, sizeof(trigger34),
			trigger34, TRG_ignore_perm, ODS_8_1 },
		{ "RDB$TRIGGER_35", (UCHAR) nam_chk_constr,
			RDB$TRIGGERS.RDB$TRIGGER_TYPE.POST_ERASE, sizeof(trigger35),
			trigger35, TRG_ignore_perm, ODS_8_1 },
		{ "RDB$TRIGGER_36", (UCHAR) nam_fields,
			RDB$TRIGGERS.RDB$TRIGGER_TYPE.PRE_MODIFY, sizeof(trigger36),
			trigger36, 0, ODS_11_0 },
		{ 0, 0, 0, 0, 0, 0 }
	};

	// this table is used in defining messages for system triggers

	const trigger_msg trigger_messages[] =
	{
		{ "RDB$TRIGGER_9", 0, "grant_obj_notfound", ODS_8_0 },
		{ "RDB$TRIGGER_9", 1, "grant_fld_notfound", ODS_8_0 },
		{ "RDB$TRIGGER_9", 2, "grant_nopriv", ODS_8_0 },
		{ "RDB$TRIGGER_9", 3, "nonsql_security_rel", ODS_8_0 },
		{ "RDB$TRIGGER_9", 4, "nonsql_security_fld", ODS_8_0 },
		{ "RDB$TRIGGER_9", 5, "grant_nopriv_on_base", ODS_8_0 },
		{ "RDB$TRIGGER_1", 0, "existing_priv_mod", ODS_8_0 },
		{ "RDB$TRIGGER_2", 0, "systrig_update", ODS_8_0 },
		{ "RDB$TRIGGER_3", 0, "systrig_update", ODS_8_0 },
		{ "RDB$TRIGGER_24", 1, "cnstrnt_fld_rename", ODS_8_0 },
		{ "RDB$TRIGGER_23", 1, "cnstrnt_fld_del", ODS_8_0 },
		{ "RDB$TRIGGER_22", 1, "check_trig_update", ODS_8_0 },
		{ "RDB$TRIGGER_21", 1, "check_trig_del", ODS_8_0 },
		{ "RDB$TRIGGER_20", 1, "integ_index_mod", ODS_8_0 },
		{ "RDB$TRIGGER_20", 2, "integ_index_deactivate", ODS_8_0 },
		{ "RDB$TRIGGER_20", 3, "integ_deactivate_primary", ODS_8_0 },
		{ "RDB$TRIGGER_19", 1, "integ_index_del", ODS_8_0 },
		{ "RDB$TRIGGER_18", 1, "integ_index_seg_mod", ODS_8_0 },
		{ "RDB$TRIGGER_17", 1, "integ_index_seg_del", ODS_8_0 },
		{ "RDB$TRIGGER_15", 1, "check_cnstrnt_del", ODS_8_0 },
		{ "RDB$TRIGGER_14", 1, "check_cnstrnt_update", ODS_8_0 },
		{ "RDB$TRIGGER_13", 1, "ref_cnstrnt_update", ODS_8_0 },
		{ "RDB$TRIGGER_12", 1, "ref_cnstrnt_notfound", ODS_8_0 },
		{ "RDB$TRIGGER_12", 2, "foreign_key_notfound", ODS_8_0 },
		{ "RDB$TRIGGER_10", 1, "primary_key_ref", ODS_8_0 },
		{ "RDB$TRIGGER_10", 2, "primary_key_notnull", ODS_8_0 },
		{ "RDB$TRIGGER_25", 1, "rel_cnstrnt_update", ODS_8_0 },
		{ "RDB$TRIGGER_26", 1, "constaint_on_view", ODS_8_0 },
		{ "RDB$TRIGGER_26", 2, "invld_cnstrnt_type", ODS_8_0 },
		{ "RDB$TRIGGER_26", 3, "primary_key_exists", ODS_8_0 },
		{ "RDB$TRIGGER_24", 2, "integ_index_seg_mod", ODS_11_0 },
		{ "RDB$TRIGGER_36", 1, "integ_index_seg_mod", ODS_11_0 },
		{ 0, 0, 0, 0 }
	};

	bool getCharsetByTextType(SSHORT& charSet, const USHORT subType)
	{
		switch (subType)
		{
		case dsc_text_type_metadata:
			charSet = CS_METADATA;
			break;

		case dsc_text_type_ascii:
			charSet = CS_ASCII;
			break;

		case dsc_text_type_fixed:
			charSet = CS_BINARY;
			break;

		default:
			return false;
		}

		return true;
	}

	SLONG lookupGenerator(const MetaName& name)
	{
		for (const gen* generator = generators; generator->gen_name; generator++)
		{
			if (name == generator->gen_name)
				return generator->gen_id;
		}

		fb_assert(false);
		return -1;
	}

	void storeGrant(thread_db* tdbb, const char* user, USHORT user_type,
		const char* object, USHORT object_type, const char* prvl)
	{
		const auto attachment = tdbb->getAttachment();
		const auto transaction = tdbb->getTransaction();

		AutoRequest handle;

		while (*prvl)
		{
			STORE(REQUEST_HANDLE handle TRANSACTION_HANDLE transaction)
				PRIV IN RDB$USER_PRIVILEGES
			{
				PAD(user, PRIV.RDB$USER);
				PAD(object, PRIV.RDB$RELATION_NAME);
				PRIV.RDB$FIELD_NAME.NULL = TRUE;
				PRIV.RDB$PRIVILEGE[0] = *prvl++;
				PRIV.RDB$PRIVILEGE[1] = 0;
				PRIV.RDB$GRANT_OPTION = 0;
				PRIV.RDB$USER_TYPE = user_type;
				PRIV.RDB$OBJECT_TYPE = object_type;
				PRIV.RDB$GRANTOR.NULL = TRUE;
			}
			END_STORE
		}
	}

	class SecurityHelper
	{
		static const unsigned FB_MAX_ACL_SIZE = 4096;

	public:
		SecurityHelper(const MetaName& ownerName, AutoRequest& handle)
			: userName(ownerName), reqAddSC(handle)
		{}

		const char* getOwnerName() const
		{
			return userName.c_str();
		}

		void addSecurityClass(thread_db* tdbb, const MetaName& className)
		{
			const auto attachment = tdbb->getAttachment();
			const auto transaction = tdbb->getTransaction();

			bid blobId;
			attachment->storeBinaryBlob(tdbb, transaction, &blobId, ByteChunk(buffer, length));

			STORE(REQUEST_HANDLE reqAddSC TRANSACTION_HANDLE transaction)
				CLS IN RDB$SECURITY_CLASSES
			{
				PAD(className, CLS.RDB$SECURITY_CLASS);
				CLS.RDB$ACL = blobId;
			}
			END_STORE
		}

	protected:
		UCHAR buffer[FB_MAX_ACL_SIZE];
		ULONG length = 0;

	private:
		const MetaName userName;
		AutoRequest& reqAddSC;
	};

	class RelationSecurity : public SecurityHelper
	{
	public:
		RelationSecurity(const MetaName& ownerName, AutoRequest& handle)
			: SecurityHelper(ownerName, handle)
		{
			const size_t ownerNameLength = ownerName.length();
			fb_assert(ownerNameLength <= MAX_UCHAR);

			const UCHAR REL_OWNER_ACL[] =
				{ACL_priv_list, priv_control, priv_alter, priv_drop,
				 priv_select, priv_insert, priv_update, priv_delete, ACL_end};

			const UCHAR REL_PUBLIC_ACL[] =
				{ACL_priv_list, priv_select, ACL_end};

			fb_assert(sizeof(buffer) >= 8 + ownerNameLength +
					  sizeof(REL_OWNER_ACL) + sizeof(REL_PUBLIC_ACL));

			UCHAR* acl = buffer;
			*acl++ = ACL_version;
			*acl++ = ACL_id_list;

			*acl++ = id_person;

			*acl++ = (UCHAR) ownerNameLength;
			memcpy(acl, ownerName.c_str(), ownerNameLength);
			acl += ownerNameLength;

			*acl++ = ACL_end;

			memcpy(acl, REL_OWNER_ACL, sizeof(REL_OWNER_ACL));
			acl += sizeof(REL_OWNER_ACL);

			*acl++ = ACL_id_list;
			*acl++ = ACL_end;

			memcpy(acl, REL_PUBLIC_ACL, sizeof(REL_PUBLIC_ACL));
			acl += sizeof(REL_PUBLIC_ACL);

			*acl++ = ACL_end; // Extra terminator to avoid scl.epp:walk_acl() missing the end

			length = acl - buffer;
		}

		void storeSecurityClass(thread_db* tdbb, MetaName& securityClass, MetaName& defaultClass)
		{
			securityClass.printf("%s%" SQUADFORMAT, SQL_SECCLASS_PREFIX,
				DPM_gen_id(tdbb, lookupGenerator(SQL_SECCLASS_GENERATOR), false, 1));

			defaultClass.printf("%s%" SQUADFORMAT, DEFAULT_CLASS,
				DPM_gen_id(tdbb, lookupGenerator(DEFAULT_CLASS), false, 1));

			addSecurityClass(tdbb, securityClass);
			addSecurityClass(tdbb, defaultClass);
		}

		void storePrivileges(thread_db* tdbb, const char* relName)
		{
			// Only the owner of the database has SELECT/INSERT/UPDATE/DELETE privileges
			// on any system relations. Any other users only has SELECT privilege.

			const auto attachment = tdbb->getAttachment();
			const auto transaction = tdbb->getTransaction();

			const auto userName = getOwnerName();

			for (int cnt = 0; cnt < 6; cnt++)
			{
				STORE(REQUEST_HANDLE handle TRANSACTION_HANDLE transaction)
					PRIV IN RDB$USER_PRIVILEGES
				{
					switch (cnt)
					{
					case 0:
						strcpy(PRIV.RDB$USER, userName);
						PRIV.RDB$PRIVILEGE[0] = 'S';
						PRIV.RDB$GRANT_OPTION = WITH_GRANT_OPTION;
						break;
					case 1:
						strcpy(PRIV.RDB$USER, userName);
						PRIV.RDB$PRIVILEGE[0] = 'I';
						PRIV.RDB$GRANT_OPTION = WITH_GRANT_OPTION;
						break;
					case 2:
						strcpy(PRIV.RDB$USER, userName);
						PRIV.RDB$PRIVILEGE[0] = 'U';
						PRIV.RDB$GRANT_OPTION = WITH_GRANT_OPTION;
						break;
					case 3:
						strcpy(PRIV.RDB$USER, userName);
						PRIV.RDB$PRIVILEGE[0] = 'D';
						PRIV.RDB$GRANT_OPTION = WITH_GRANT_OPTION;
						break;
					case 4:
						strcpy(PRIV.RDB$USER, userName);
						PRIV.RDB$PRIVILEGE[0] = 'R';
						PRIV.RDB$GRANT_OPTION = WITH_GRANT_OPTION;
						break;
					default:
						strcpy(PRIV.RDB$USER, "PUBLIC");
						PRIV.RDB$PRIVILEGE[0] = 'S';
						PRIV.RDB$GRANT_OPTION = 0;
						break;
					}

					PRIV.RDB$PRIVILEGE[1] = 0;
					PRIV.RDB$GRANTOR.NULL = TRUE;
					strcpy(PRIV.RDB$RELATION_NAME, relName);
					PRIV.RDB$FIELD_NAME.NULL = TRUE;
					PRIV.RDB$USER_TYPE = obj_user;
					PRIV.RDB$OBJECT_TYPE = obj_relation;
				}
				END_STORE
			}
		}

	private:
		AutoRequest handle;
	};

	class NonRelationSecurity : public SecurityHelper
	{
	public:
		NonRelationSecurity(const MetaName& ownerName, AutoRequest& handle, bool package)
			: SecurityHelper(ownerName, handle)
		{
			const size_t ownerNameLength = ownerName.length();
			fb_assert(ownerNameLength <= MAX_UCHAR);

			const UCHAR privilege = package ? priv_execute : priv_usage;

			const UCHAR NON_REL_OWNER_ACL[] =
				{ACL_priv_list, priv_control, priv_alter, priv_drop, privilege, ACL_end};

			const UCHAR NON_REL_PUBLIC_ACL[] =
				{ACL_priv_list, privilege, ACL_end};

			fb_assert(sizeof(buffer) >= 8 + ownerNameLength +
					  sizeof(NON_REL_OWNER_ACL) + sizeof(NON_REL_PUBLIC_ACL));

			UCHAR* acl = buffer;
			*acl++ = ACL_version;
			*acl++ = ACL_id_list;
			*acl++ = id_person;

			*acl++ = (UCHAR) ownerNameLength;
			memcpy(acl, ownerName.c_str(), ownerNameLength);
			acl += ownerNameLength;

			*acl++ = ACL_end;

			memcpy(acl, NON_REL_OWNER_ACL, sizeof(NON_REL_OWNER_ACL));
			acl += sizeof(NON_REL_OWNER_ACL);

			*acl++ = ACL_id_list;
			*acl++ = ACL_end;

			memcpy(acl, NON_REL_PUBLIC_ACL, sizeof(NON_REL_PUBLIC_ACL));
			acl += sizeof(NON_REL_PUBLIC_ACL);

			*acl++ = ACL_end; // Extra terminator to avoid scl.epp:walk_acl() missing the end

			length = acl - buffer;
		}

		MetaName storeSecurityClass(thread_db* tdbb)
		{
			MetaName securityClass;
			securityClass.printf("%s%" SQUADFORMAT, SQL_SECCLASS_PREFIX,
				DPM_gen_id(tdbb, lookupGenerator(SQL_SECCLASS_GENERATOR), false, 1));

			addSecurityClass(tdbb, securityClass);

			return securityClass;
		}

		void storePrivileges(thread_db* tdbb, const char* objName, ObjectType objType)
		{
			// Add security to system objects

			const auto attachment = tdbb->getAttachment();
			const auto transaction = tdbb->getTransaction();

			const char* privileges = nullptr;

			switch (objType)
			{
			case obj_field:
			case obj_charset:
			case obj_collation:
			case obj_exception:
			case obj_generator:
				privileges = USAGE_PRIVILEGES;
				break;

			case obj_package_header:
				privileges = EXEC_PRIVILEGES;
				break;

			default:
				fb_assert(false);
			}

			fb_assert(privileges && privileges[0] && !privileges[1]);

			auto userName = getOwnerName();
			fb_assert(userName && *userName);
			fb_assert(objName);

			const char* users[] = {userName, "PUBLIC"};
			int grantOptions[] = {WITH_GRANT_OPTION, 0};

			for (unsigned i = 0; i < FB_NELEM(users); i++)
			{
				STORE(REQUEST_HANDLE handle TRANSACTION_HANDLE transaction)
					PRIV IN RDB$USER_PRIVILEGES
				{
					PAD(users[i], PRIV.RDB$USER);
					PAD(objName, PRIV.RDB$RELATION_NAME);
					PRIV.RDB$PRIVILEGE[0] = *privileges;
					PRIV.RDB$PRIVILEGE[1] = 0;
					PRIV.RDB$GRANT_OPTION = grantOptions[i];
					PRIV.RDB$USER_TYPE = obj_user;
					PRIV.RDB$OBJECT_TYPE = objType;
					PRIV.RDB$GRANTOR.NULL = TRUE;
				}
				END_STORE
			}
		}

	private:
		AutoRequest handle;
	};

	class RoleSecurity : public SecurityHelper
	{
	public:
		RoleSecurity(const MetaName& ownerName, AutoRequest& handle)
			: SecurityHelper(ownerName, handle)
		{
			const size_t ownerNameLength = ownerName.length();
			fb_assert(ownerNameLength <= MAX_UCHAR);

			const UCHAR ROLE_OWNER_ACL[] =
				{ACL_priv_list, priv_control, priv_alter, priv_drop, priv_usage, ACL_end};

			fb_assert(sizeof(buffer) >= 6 + ownerNameLength + sizeof(ROLE_OWNER_ACL));

			UCHAR* acl = buffer;
			*acl++ = ACL_version;
			*acl++ = ACL_id_list;
			*acl++ = id_person;

			*acl++ = (UCHAR) ownerNameLength;
			memcpy(acl, ownerName.c_str(), ownerNameLength);
			acl += ownerNameLength;

			*acl++ = ACL_end;

			memcpy(acl, ROLE_OWNER_ACL, sizeof(ROLE_OWNER_ACL));
			acl += sizeof(ROLE_OWNER_ACL);

			*acl++ = ACL_end; // Extra terminator to avoid scl.epp:walk_acl() missing the end

			length = acl - buffer;
		}

		MetaName storeSecurityClass(thread_db* tdbb)
		{
			MetaName securityClass;
			securityClass.printf("%s%" SQUADFORMAT, SQL_SECCLASS_PREFIX,
				DPM_gen_id(tdbb, lookupGenerator(SQL_SECCLASS_GENERATOR), false, 1));

			addSecurityClass(tdbb, securityClass);

			return securityClass;
		}

		void storePrivileges(thread_db* tdbb, const char* objName)
		{
			// Add security to system roles

			const auto attachment = tdbb->getAttachment();
			const auto transaction = tdbb->getTransaction();

			const auto userName = getOwnerName();
			fb_assert(userName && *userName);
			fb_assert(objName);

			const char* users[] = {DBA_USER_NAME, userName};
			const unsigned usersCount = (MetaName(userName) != DBA_USER_NAME) ? 2 : 1;

			const char* privilege = "M";

			for (unsigned i = 0; i < usersCount; i++)
			{
				STORE(REQUEST_HANDLE handle TRANSACTION_HANDLE transaction)
					PRIV IN RDB$USER_PRIVILEGES
				{
					PAD(users[i], PRIV.RDB$USER);
					PAD(objName, PRIV.RDB$RELATION_NAME);
					PRIV.RDB$PRIVILEGE[0] = *privilege;
					PRIV.RDB$PRIVILEGE[1] = 0;
					PRIV.RDB$GRANT_OPTION = WITH_ADMIN_OPTION;
					PRIV.RDB$USER_TYPE = obj_user;
					PRIV.RDB$OBJECT_TYPE = obj_sql_role;
					PRIV.RDB$GRANTOR.NULL = TRUE;

					// Grant role as default
					PRIV.RDB$FIELD_NAME[0] = 'D';
					PRIV.RDB$FIELD_NAME[1] = 0;
					PRIV.RDB$FIELD_NAME.NULL = FALSE;
				}
				END_STORE
			}
		}

	private:
		AutoRequest handle;
	};

	class DdlSecurity : public SecurityHelper
	{
	public:
		DdlSecurity(const MetaName& ownerName, AutoRequest& handle)
			: SecurityHelper(ownerName, handle)
		{
			const size_t ownerNameLength = ownerName.length();
			fb_assert(ownerNameLength <= MAX_UCHAR);

			const UCHAR DDL_OWNER_ACL[] =
				{ACL_priv_list, priv_control, priv_alter, priv_drop, ACL_end};

			const UCHAR DDL_PUBLIC_ACL[] =
				{ACL_priv_list, ACL_end};

			fb_assert(sizeof(buffer) >= 8 + ownerNameLength +
					  sizeof(DDL_OWNER_ACL) + sizeof(DDL_PUBLIC_ACL));

			UCHAR* acl = buffer;
			*acl++ = ACL_version;
			*acl++ = ACL_id_list;
			*acl++ = id_person;

			*acl++ = (UCHAR) ownerNameLength;
			memcpy(acl, ownerName.c_str(), ownerNameLength);
			acl += ownerNameLength;

			*acl++ = ACL_end;

			memcpy(acl, DDL_OWNER_ACL, sizeof(DDL_OWNER_ACL));
			acl += sizeof(DDL_OWNER_ACL);

			*acl++ = ACL_id_list;
			*acl++ = ACL_end;
			memcpy(acl, DDL_PUBLIC_ACL, sizeof(DDL_PUBLIC_ACL));
			acl += sizeof(DDL_PUBLIC_ACL);

			*acl++ = ACL_end; // Extra terminator to avoid scl.epp:walk_acl() missing the end

			length = acl - buffer;
		}

		void store(thread_db* tdbb)
		{
			const auto attachment = tdbb->getAttachment();
			const auto transaction = tdbb->getTransaction();

			for (int obj = obj_database + 1; obj < obj_type_MAX; obj++)
			{
				if (isDdlObject(obj))
					addSecurityClass(tdbb, getSecurityClassName(obj));
			}

			MetaName securityClass;
			securityClass.printf("%s%" SQUADFORMAT, SQL_SECCLASS_PREFIX,
				DPM_gen_id(tdbb, lookupGenerator(SQL_SECCLASS_GENERATOR), false, 1));

			addSecurityClass(tdbb, securityClass);

			FOR(REQUEST_HANDLE handle TRANSACTION_HANDLE transaction)
				DB IN RDB$DATABASE
			{
				MODIFY DB USING
					DB.RDB$SECURITY_CLASS.NULL = FALSE;
					PAD(securityClass, DB.RDB$SECURITY_CLASS);
				END_MODIFY
			}
			END_FOR
		}

	private:
		AutoRequest handle;
	};

}; // namespace

static void store_admin_role(thread_db*, const MetaName&, RoleSecurity&);
static void store_default_pub(thread_db*, const MetaName&);
static void store_generator(thread_db*, const gen*, AutoRequest&, NonRelationSecurity&);
static void store_global_field(thread_db*, const gfld*, AutoRequest&, NonRelationSecurity&);
static void store_indices(thread_db*, USHORT = 0);
static void store_intlnames(thread_db*, NonRelationSecurity&);
static void store_message(thread_db*, const trigger_msg*, AutoRequest&);
static void store_relation(thread_db*, int, const char*, int, int, AutoRequest&, RelationSecurity&);
static void store_relation_field(thread_db*, int, const char*, const char*, const char*, int, AutoRequest&);
static void store_packages(thread_db*, NonRelationSecurity&, USHORT = 0);
static void store_trigger(thread_db*, const jrd_trg*, AutoRequest&);


void INI_format(thread_db* tdbb, const string& charset)
{
/**************************************
 *
 *	I N I _ f o r m a t
 *
 **************************************
 *
 * Functional description
 *	Initialize system relations in the database.
 *	The full complement of metadata should be
 *	stored here.
 *
 **************************************/
	const auto dbb = tdbb->getDatabase();
	const auto attachment = tdbb->getAttachment();
	const auto transaction = attachment->getSysTransaction();

	tdbb->setTransaction(transaction);

	// Uppercase owner name
	const auto ownerName = attachment->getUserName();
	fb_assert(ownerName.hasData());

	AutoRequest handle, reqAddSC;

	{ // scope for system relations

		RelationSecurity relSec(ownerName, reqAddSC);

		const int* fld;

		// Make sure relations exist already

		for (const int* relfld = relfields; relfld[RFLD_R_NAME]; relfld = fld + 1)
		{
			if (relfld[RFLD_R_TYPE] == rel_persistent)
				DPM_create_relation(tdbb, MET_relation(tdbb, relfld[RFLD_R_ID]));

			for (fld = relfld + RFLD_RPT; fld[RFLD_F_NAME]; fld += RFLD_F_LENGTH)
				;
		}

		// Store RELATIONS and RELATION_FIELDS

		AutoRequest handle2;

		for (const int* relfld = relfields; relfld[RFLD_R_NAME]; relfld = fld + 1)
		{
			int fieldId = 0;

			for (fld = relfld + RFLD_RPT; fld[RFLD_F_NAME]; fld += RFLD_F_LENGTH)
			{
				const gfld* gfield = &gfields[fld[RFLD_F_ID]];
				const auto relId = relfld[RFLD_R_ID];
				const auto relName = names[relfld[RFLD_R_NAME]];
				const auto fieldName = names[fld[RFLD_F_NAME]];
				const auto globalName = names[gfield->gfld_name];
				const auto updateFlag = fld[RFLD_F_UPDATE];

				store_relation_field(tdbb, fieldId, relName, fieldName, globalName,
									 updateFlag, handle2);
				++fieldId;
			}

			const auto relId = relfld[RFLD_R_ID];
			const auto relName = names[relfld[RFLD_R_NAME]];
			const auto relType = relfld[RFLD_R_TYPE];

			store_relation(tdbb, relId, relName, fieldId, relType, handle, relSec);
		}
	}

	NonRelationSecurity nonRelSec(ownerName, reqAddSC, false);

	// Store global FIELDS

	handle.reset();

	for (const gfld* gfield = gfields; gfield->gfld_name; gfield++)
		store_global_field(tdbb, gfield, handle, nonRelSec);

	// Store DATABASE record

	handle.reset();

	// Uppercase charset name
	MetaName charSetName(charset.hasData() ? charset : DEFAULT_DB_CHARACTER_SET_NAME);

	STORE(REQUEST_HANDLE handle) X IN RDB$DATABASE
	{
		X.RDB$RELATION_ID = (int) USER_DEF_REL_INIT_ID;
		PAD(charSetName, X.RDB$CHARACTER_SET_NAME);
		X.RDB$CHARACTER_SET_NAME.NULL = FALSE;
	}
	END_STORE

	// Create indices for system relations

	store_indices(tdbb);

	// Create parameter types

	handle.reset();

	for (const rtyp* type = types; type->rtyp_name; ++type)
	{
		// this STORE should be compatible with two below,
		// as they use the same compiled request
		STORE(REQUEST_HANDLE handle) X IN RDB$TYPES
		{
			PAD(names[type->rtyp_field], X.RDB$FIELD_NAME);
			PAD(type->rtyp_name, X.RDB$TYPE_NAME);
			X.RDB$TYPE = type->rtyp_value;
			X.RDB$SYSTEM_FLAG = RDB_system;
			X.RDB$SYSTEM_FLAG.NULL = FALSE;
		}
		END_STORE
	}

	for (const IntlManager::CharSetDefinition* charSet = IntlManager::defaultCharSets;
		 charSet->name; ++charSet)
	{
		// this STORE should be compatible with one above and below,
		// as they use the same compiled request
		STORE(REQUEST_HANDLE handle) X IN RDB$TYPES
		{
			PAD(names[nam_charset_name], X.RDB$FIELD_NAME);
			PAD(charSet->name, X.RDB$TYPE_NAME);
			X.RDB$TYPE = charSet->id;
			X.RDB$SYSTEM_FLAG = RDB_system;
			X.RDB$SYSTEM_FLAG.NULL = FALSE;
		}
		END_STORE;
	}

	for (const IntlManager::CharSetAliasDefinition* alias = IntlManager::defaultCharSetAliases;
		alias->name; ++alias)
	{
		// this STORE should be compatible with two above,
		// as they use the same compiled request
		STORE(REQUEST_HANDLE handle) X IN RDB$TYPES
		{
			PAD(names[nam_charset_name], X.RDB$FIELD_NAME);
			PAD(alias->name, X.RDB$TYPE_NAME);
			X.RDB$TYPE = alias->charSetId;
			X.RDB$SYSTEM_FLAG = RDB_system;
			X.RDB$SYSTEM_FLAG.NULL = FALSE;
		}
		END_STORE;
	}

	// Store symbols for international character sets & collations

	store_intlnames(tdbb, nonRelSec);

	// Create system generators

	handle.reset();

	for (const gen* generator = generators; generator->gen_name; generator++)
		store_generator(tdbb, generator, handle, nonRelSec);

	// Adjust the value of the hidden generator RDB$GENERATORS
	DPM_gen_id(tdbb, 0, true, FB_NELEM(generators) - 1);

	// Store system-defined triggers

	handle.reset();

	for (const jrd_trg* trigger = triggers; trigger->trg_relation; ++trigger)
		store_trigger(tdbb, trigger, handle);

	// Store trigger messages to go with triggers

	handle.reset();

	for (const trigger_msg* message = trigger_messages; message->trigmsg_name; ++message)
		store_message(tdbb, message, handle);

	// Create system packages

	// Reset nonRelSec for package permissions, it should be its last usage in this function
	new(&nonRelSec) NonRelationSecurity(ownerName, reqAddSC, true);

	store_packages(tdbb, nonRelSec);

	// Store default publication

	store_default_pub(tdbb, ownerName);

	// Store system role

	RoleSecurity roleSec(ownerName, reqAddSC);
	store_admin_role(tdbb, ADMIN_ROLE, roleSec);

	// Add default DDL security

	DdlSecurity(ownerName, reqAddSC).store(tdbb);

	// Add additional grants

	MetaName buf;

	buf.printf("%d", USE_NBACKUP_UTILITY);
	storeGrant(tdbb, buf.c_str(), obj_privilege, "RDB$BACKUP_HISTORY", obj_relation, "SIUDR");
	GRANT_privileges(tdbb, "RDB$BACKUP_HISTORY", obj_relation, transaction);

	buf.printf("%d", CREATE_USER_TYPES);
	storeGrant(tdbb, buf.c_str(), obj_privilege, "RDB$TYPES", obj_relation, "SIUDR");
	GRANT_privileges(tdbb, "RDB$TYPES", obj_relation, transaction);

	buf.printf("%d", GRANT_REVOKE_ANY_DDL_RIGHT);
	storeGrant(tdbb, buf.c_str(), obj_privilege, "RDB$DB_CREATORS", obj_relation, "SIUDR");
	GRANT_privileges(tdbb, "RDB$DB_CREATORS", obj_relation, transaction);

	DFW_perform_system_work(tdbb);

	tdbb->setTransaction(nullptr);
}


USHORT INI_get_trig_flags(const MetaName& triggerName)
{
/*********************************************
 *
 *      I N I _ g e t _ t r i g _ f l a g s
 *
 *********************************************
 *
 * Functional description
 *      Return the trigger flags for a system trigger.
 *
 **************************************/
	for (const jrd_trg* trig = triggers; trig->trg_length > 0; trig++)
	{
		if (triggerName == trig->trg_name)
			return trig->trg_flags;
	}

	return 0;
}


void INI_init(thread_db* tdbb)
{
/**************************************
 *
 *	I N I _ i n i t
 *
 **************************************
 *
 * Functional description
 *	Initialize in memory meta data.  Assume that all meta data
 *	fields exist in the database even if this is not the case.
 *	Do not fill in the format length or the address in each
 *	format descriptor.
 *
 **************************************/
	SET_TDBB(tdbb);
	const auto dbb = tdbb->getDatabase();
	const auto attachment = tdbb->getAttachment();
	const auto pool = attachment->att_pool;

	const int* fld;
	for (const int* relfld = relfields; relfld[RFLD_R_NAME]; relfld = fld + 1)
	{
		jrd_rel* relation = MET_relation(tdbb, relfld[RFLD_R_ID]);
		relation->rel_flags |= REL_system;
		relation->rel_flags |= MET_get_rel_flags_from_TYPE(relfld[RFLD_R_TYPE]);
		relation->rel_name = names[relfld[RFLD_R_NAME]];
		int n = 0;
		for (fld = relfld + RFLD_RPT; fld[RFLD_F_NAME]; fld += RFLD_F_LENGTH)
		{
			n++;
		}

		// Set a flag if their is a trigger on the relation.  Later we may need to compile it.

		for (const jrd_trg* trigger = triggers; trigger->trg_relation; trigger++)
		{
			if (relation->rel_name == names[trigger->trg_relation])
			{
				relation->rel_flags |= REL_sys_triggers;
				break;
			}
		}

		vec<jrd_fld*>* fields = vec<jrd_fld*>::newVector(*pool, n);
		relation->rel_fields = fields;
		vec<jrd_fld*>::iterator itr = fields->begin();
		Format* format = Format::newFormat(*pool, n);
		relation->rel_current_format = format;
		vec<Format*>* formats = vec<Format*>::newVector(*pool, 1);
		relation->rel_formats = formats;
		(*formats)[0] = format;
		Format::fmt_desc_iterator desc = format->fmt_desc.begin();

		for (fld = relfld + RFLD_RPT; fld[RFLD_F_NAME]; fld += RFLD_F_LENGTH, ++desc, ++itr)
		{
			const gfld* gfield = &gfields[fld[RFLD_F_ID]];
			desc->dsc_length = gfield->gfld_length;
			if (gfield->gfld_dtype == dtype_varying)
			{
				fb_assert(desc->dsc_length <= MAX_USHORT - sizeof(USHORT));
				desc->dsc_length += sizeof(USHORT);
			}

			desc->dsc_dtype = gfield->gfld_dtype;

			if (desc->isText())
			{
				if (!getCharsetByTextType(desc->dsc_sub_type, gfield->gfld_sub_type))
					desc->dsc_sub_type = CS_NONE;
			}
			else
				desc->dsc_sub_type = gfield->gfld_sub_type;

			if (desc->dsc_dtype == dtype_blob && desc->dsc_sub_type == isc_blob_text)
				desc->dsc_scale = CS_METADATA;	// blob charset

			jrd_fld* field = FB_NEW_POOL(*pool) jrd_fld(*pool);
			*itr = field;
			field->fld_name = names[fld[RFLD_F_NAME]];
		}
	}
}


void INI_init2(thread_db* tdbb)
{
/**************************************
 *
 *	I N I _ i n i t 2
 *
 **************************************
 *
 * Functional description
 *	Re-initialize in memory meta data.  Fill in
 *	format 0 based on the minor ODS version of
 *	the database when it was created.
 *
 **************************************/
	SET_TDBB(tdbb);
	const auto dbb = tdbb->getDatabase();

	const USHORT major_version = dbb->dbb_ods_version;
	const USHORT minor_version = dbb->dbb_minor_version;
	vec<jrd_rel*>* vector = tdbb->getAttachment()->att_relations;

	const int* fld;
	for (const int* relfld = relfields; relfld[RFLD_R_NAME]; relfld = fld + 1)
	{
		if (relfld[RFLD_R_ODS] > ENCODE_ODS(major_version, minor_version))
		{
			// free the space allocated for RDB$ROLES

			const USHORT id = relfld[RFLD_R_ID];
			jrd_rel* relation = (*vector)[id];
			delete relation->rel_current_format;
			delete relation->rel_formats;
			delete relation->rel_fields;
			delete relation;
			(*vector)[id] = NULL;
			fld = relfld + RFLD_RPT;
			while (fld[RFLD_F_NAME])
			{
				fld += RFLD_F_LENGTH;
			}
		}
		else
		{
			jrd_rel* relation = MET_relation(tdbb, relfld[RFLD_R_ID]);
			Format* format = relation->rel_current_format;

			int n = 0;
			for (fld = relfld + RFLD_RPT; fld[RFLD_F_NAME]; fld += RFLD_F_LENGTH)
			{
				if (ENCODE_ODS(major_version, minor_version) >= fld[RFLD_F_ODS])
					n++;
			}

			relation->rel_fields->resize(n);
			format->fmt_count = n; // We are using less than the allocated members.
			format->fmt_length = FLAG_BYTES(n);
			Format::fmt_desc_iterator desc = format->fmt_desc.begin();
			for (fld = relfld + RFLD_RPT; fld[RFLD_F_NAME]; fld += RFLD_F_LENGTH, ++desc)
			{
				if (n-- > 0)
				{
					format->fmt_length = MET_align(&(*desc), format->fmt_length);
					desc->dsc_address = (UCHAR*)(IPTR) format->fmt_length;
					format->fmt_length += desc->dsc_length;
				}
			}
		}
	}
}


// Load system objects into DSQL metadata cache.
void INI_init_dsql(thread_db* tdbb, dsql_dbb* database)
{
	SET_TDBB(tdbb);
	const auto dbb = tdbb->getDatabase();

	const USHORT majorVersion = dbb->dbb_ods_version;
	const USHORT minorVersion = dbb->dbb_minor_version;
	const int* fld;

	// Load relation and fields.

	for (const int* relfld = relfields; relfld[RFLD_R_NAME]; relfld = fld + 1)
	{
		if (relfld[RFLD_R_ODS] > ENCODE_ODS(majorVersion, minorVersion))
		{
			for (fld = relfld + RFLD_RPT; fld[RFLD_F_NAME]; fld += RFLD_F_LENGTH)
				;

			continue;
		}

		dsql_rel* relation = FB_NEW_POOL(database->dbb_pool) dsql_rel(database->dbb_pool);

		relation->rel_id = relfld[RFLD_R_ID];
		relation->rel_name = names[relfld[RFLD_R_NAME]];
		relation->rel_owner = DBA_USER_NAME;
		relation->rel_dbkey_length = 8;

		dsql_fld** ptr = &relation->rel_fields;
		int n = 0;

		for (fld = relfld + RFLD_RPT; fld[RFLD_F_NAME]; fld += RFLD_F_LENGTH)
		{
			if (ENCODE_ODS(majorVersion, minorVersion) < fld[RFLD_F_ODS])
				continue;

			dsql_fld* field = FB_NEW_POOL(database->dbb_pool) dsql_fld(database->dbb_pool);
			field->fld_id = n++;

			*ptr = field;
			ptr = &field->fld_next;

			// get field information

			const gfld* gfield = &gfields[fld[RFLD_F_ID]];

			field->fld_name = names[fld[RFLD_F_NAME]];
			field->fieldSource = names[gfield->gfld_name];
			field->length = gfield->gfld_length;
			field->scale = 0;
			field->subType = gfield->gfld_sub_type;
			field->fld_relation = relation;

			field->dtype = gfield->gfld_dtype;

			if (field->dtype == dtype_varying)
				field->length += sizeof(USHORT);
			else if (field->dtype == dtype_blob)
			{
				field->segLength = 80;
				if (gfield->gfld_sub_type == isc_blob_text)
					field->charSetId = CS_METADATA;
			}

			if (DTYPE_IS_TEXT(gfield->gfld_dtype))
			{
				if (getCharsetByTextType(field->charSetId.value, gfield->gfld_sub_type))
					field->charSetId.specified = true;
			}

			if (gfield->gfld_nullable)
				field->flags |= FLD_nullable;

			field->flags |= FLD_system;
		}

		database->dbb_relations.put(relation->rel_name, relation);
		MET_dsql_cache_use(tdbb, SYM_relation, relation->rel_name);
	}

	// Load internal character sets and collations, necessary for engine operation.

	for (const IntlManager::CharSetDefinition* csDef = IntlManager::defaultCharSets;
		 csDef->name; ++csDef)
	{
		if (csDef->id > ttype_last_internal)
			continue;

		dsql_intlsym* csSymbol = FB_NEW_POOL(database->dbb_pool) dsql_intlsym(database->dbb_pool);
		csSymbol->intlsym_name = csDef->name;
		csSymbol->intlsym_charset_id = csDef->id;
		csSymbol->intlsym_collate_id = 0;
		csSymbol->intlsym_ttype =
			INTL_CS_COLL_TO_TTYPE(csSymbol->intlsym_charset_id, csSymbol->intlsym_collate_id);
		csSymbol->intlsym_bytes_per_char = csDef->maxBytes;

		// Mark the charset as invalid to reload it ASAP. This is done because we cannot know here
		// if the user has altered its default collation.
		csSymbol->intlsym_flags = INTLSYM_dropped;

		database->dbb_charsets.put(csDef->name, csSymbol);
		database->dbb_charsets_by_id.put(csSymbol->intlsym_charset_id, csSymbol);
		MET_dsql_cache_use(tdbb, SYM_intlsym_charset, csDef->name);

		for (const IntlManager::CollationDefinition* colDef = IntlManager::defaultCollations;
			 colDef->name; ++colDef)
		{
			if (colDef->charSetId != csDef->id)
				continue;

			dsql_intlsym* colSymbol = FB_NEW_POOL(database->dbb_pool) dsql_intlsym(database->dbb_pool);
			colSymbol->intlsym_name = colDef->name;
			colSymbol->intlsym_flags = 0;
			colSymbol->intlsym_charset_id = csDef->id;
			colSymbol->intlsym_collate_id = colDef->collationId;
			colSymbol->intlsym_ttype =
				INTL_CS_COLL_TO_TTYPE(colSymbol->intlsym_charset_id, colSymbol->intlsym_collate_id);
			colSymbol->intlsym_bytes_per_char = csDef->maxBytes;

			database->dbb_collations.put(colDef->name, colSymbol);
			MET_dsql_cache_use(tdbb, SYM_intlsym_collation, colDef->name);
		}
	}
}


string INI_owner_privileges()
{
	return string(gfields[fld_system_privileges].gfld_length, '\xff');
}


void INI_upgrade(thread_db* tdbb)
{
/**************************************
 *
 *	I N I _ u p g r a d e
 *
 **************************************
 *
 * Functional description
 *	Upgrade minor ODS version.
 *
 **************************************/
	const auto dbb = tdbb->getDatabase();
	const auto attachment = tdbb->getAttachment();

	// If database is read-only, punt
	if (dbb->dbb_flags & DBB_read_only)
		Arg::Gds(isc_read_only).raise();

	// Check current ODS version to see if we have work to do

	const auto majorVersion = dbb->dbb_ods_version;
	fb_assert(majorVersion == ODS_VERSION);

	const auto minorVersion = dbb->dbb_minor_version;
	if (minorVersion == ODS_CURRENT)
		return;

	const auto odsVersion = ENCODE_ODS(majorVersion, minorVersion);

	const auto transaction = TRA_start(tdbb, TRA_no_auto_undo, 0);
	tdbb->setTransaction(transaction);

	const int* fld;
	const char* context = nullptr;

	try {

	// Get the database owner

	const auto ownerName = dbb->dbb_owner;

	AutoRequest handle, reqAddSC;

	// Create new system relations and new relation fields

	context = "tables";
	handle.reset();

	{ // scope for system relations

		RelationSecurity relSec(ownerName, reqAddSC);

		// Make sure relations exist already

		for (const int* relfld = relfields; relfld[RFLD_R_NAME]; relfld = fld + 1)
		{
			if (relfld[RFLD_R_TYPE] == rel_persistent && relfld[RFLD_R_ODS] > odsVersion)
				DPM_create_relation(tdbb, MET_relation(tdbb, relfld[RFLD_R_ID]));

			for (fld = relfld + RFLD_RPT; fld[RFLD_F_NAME]; fld += RFLD_F_LENGTH)
				;
		}

		AutoRequest handle2;

		for (const int* relfld = relfields; relfld[RFLD_R_NAME]; relfld = fld + 1)
		{
			int fieldId = 0;

			for (fld = relfld + RFLD_RPT; fld[RFLD_F_NAME]; fld += RFLD_F_LENGTH)
			{
				if (fld[RFLD_F_ODS] > odsVersion)
				{
					const gfld* gfield = &gfields[fld[RFLD_F_ID]];
					const auto relId = relfld[RFLD_R_ID];
					const auto relName = names[relfld[RFLD_R_NAME]];
					const auto fieldName = names[fld[RFLD_F_NAME]];
					const auto globalName = names[gfield->gfld_name];
					const auto updateFlag = fld[RFLD_F_UPDATE];

					store_relation_field(tdbb, fieldId, relName, fieldName, globalName,
										 updateFlag, handle2);
				}

				++fieldId;
			}

			if (relfld[RFLD_R_ODS] > odsVersion)
			{
				const auto relId = relfld[RFLD_R_ID];
				const auto relName = names[relfld[RFLD_R_NAME]];
				const auto relType = relfld[RFLD_R_TYPE];

				store_relation(tdbb, relId, relName, fieldId, relType, handle, relSec);
			}
		}
	}

	NonRelationSecurity nonRelSec(ownerName, reqAddSC, false);

	// Create global fields added after the original minor ODS

	context = "domains";
	handle.reset();

	for (const gfld* gfield = gfields; gfield->gfld_name; gfield++)
	{
		if (gfield->gfld_ods_version > odsVersion)
			store_global_field(tdbb, gfield, handle, nonRelSec);
	}

	// Create new system indexes

	context = "indices";
	store_indices(tdbb, odsVersion);

	// Create new system triggers and their trigger messages

	context = "triggers";
	handle.reset();

	for (const jrd_trg* trigger = triggers; trigger->trg_relation; ++trigger)
	{
		if (trigger->trg_ods_version > odsVersion)
			store_trigger(tdbb, trigger, handle);
	}

	context = "trigger messages";
	handle.reset();

	for (const trigger_msg* message = trigger_messages; message->trigmsg_name; ++message)
	{
		if (message->trg_ods_version > odsVersion)
			store_message(tdbb, message, handle);
	}

	// Create new system generators

	context = "generators";
	handle.reset();

	for (const gen* generator = generators; generator->gen_name; generator++)
	{
		if (generator->gen_ods_version > odsVersion)
			store_generator(tdbb, generator, handle, nonRelSec);
	}

	// Create new system packages

	// Reset nonRelSec for package permissions, it should be its last usage in this function
	new(&nonRelSec) NonRelationSecurity(ownerName, reqAddSC, true);

	context = "packages";
	store_packages(tdbb, nonRelSec, odsVersion);

	// There are no new built-in charsets and collations introduced in ODS 13.1.
	// But if it happens in some future minor ODS, the corresponding INTL structures
	// should have the ODS field added and here we need code that conditionally adds
	// the missing charsets/collations.
	//
	// The same about the new types being introduced in minor ODS versions.

	TRA_commit(tdbb, transaction, false);

	}
	catch (const Exception& ex)
	{
		TRA_rollback(tdbb, transaction, false, true);

		// Delete relations we've just created

		for (const int* relfld = relfields; relfld[RFLD_R_NAME]; relfld = fld + 1)
		{
			if (relfld[RFLD_R_TYPE] == rel_persistent && relfld[RFLD_R_ODS] > odsVersion)
			{
				const auto relation = MET_relation(tdbb, relfld[RFLD_R_ID]);
				if (relation && relation->getBasePages()->rel_pages)
					DPM_delete_relation(tdbb, relation);
			}

			for (fld = relfld + RFLD_RPT; fld[RFLD_F_NAME]; fld += RFLD_F_LENGTH)
				;
		}

		if (context)
		{
			Arg::StatusVector error(ex);
			error.prepend(Arg::Gds(isc_ods_upgrade_err) << Arg::Str(context));
			error.raise();
		}

		throw;
	}

	// If the database was successfully updated, mark it with the current minor ODS

	win window(HEADER_PAGE_NUMBER);
	auto header = (Ods::header_page*) CCH_FETCH(tdbb, &window, LCK_write, pag_header);
	CCH_MARK(tdbb, &window);

	dbb->dbb_minor_version = header->hdr_ods_minor = ODS_CURRENT;
	CCH_RELEASE(tdbb, &window);
}


static void store_admin_role(thread_db* tdbb, const MetaName& roleName,
							 RoleSecurity& security)
{
	const MetaName ownerName = security.getOwnerName();
	const string p = INI_owner_privileges();

	const auto securityClass = security.storeSecurityClass(tdbb);

	PreparedStatement::Builder sql;
	sql << "insert into rdb$roles(rdb$role_name, rdb$owner_name, rdb$security_class, rdb$system_flag, rdb$system_privileges)"
		<< "values (" << roleName << "," << ownerName << "," << securityClass << ", 1," << p << ")";

	const auto attachment = tdbb->getAttachment();
	const auto transaction = tdbb->getTransaction();

	AutoPreparedStatement ps(attachment->prepareStatement(tdbb, transaction, sql));
	ps->execute(tdbb, transaction);

	security.storePrivileges(tdbb, roleName.c_str());
}


static void store_default_pub(thread_db* tdbb, const MetaName& ownerName)
{
	const auto attachment = tdbb->getAttachment();
	const auto transaction = tdbb->getTransaction();

	AutoRequest handle;

	STORE(REQUEST_HANDLE handle TRANSACTION_HANDLE transaction)
		PUB IN RDB$PUBLICATIONS
	{
		PAD(DEFAULT_PUBLICATION, PUB.RDB$PUBLICATION_NAME);
		PUB.RDB$PUBLICATION_NAME.NULL = FALSE;

		PAD(ownerName, PUB.RDB$OWNER_NAME);
		PUB.RDB$OWNER_NAME.NULL = FALSE;

		PUB.RDB$SYSTEM_FLAG = RDB_system;
		PUB.RDB$SYSTEM_FLAG.NULL = FALSE;

		PUB.RDB$ACTIVE_FLAG = 0;
		PUB.RDB$ACTIVE_FLAG.NULL = FALSE;

		PUB.RDB$AUTO_ENABLE = 0;
		PUB.RDB$AUTO_ENABLE.NULL = FALSE;
	}
	END_STORE
}


static void store_generator(thread_db* tdbb, const gen* generator,
							AutoRequest& handle, NonRelationSecurity& security)
{
/**************************************
 *
 *	s t o r e _ g e n e r a t o r
 *
 **************************************
 *
 * Functional description
 *	Store the passed generator according to
 *	the information in the generator block.
 *
 **************************************/
	SET_TDBB(tdbb);
	const auto attachment = tdbb->getAttachment();
	const auto transaction = tdbb->getTransaction();

	const auto ownerName = security.getOwnerName();
	const auto securityClass = security.storeSecurityClass(tdbb);

	STORE(REQUEST_HANDLE handle TRANSACTION_HANDLE transaction)
		X IN RDB$GENERATORS
	{
		PAD(generator->gen_name, X.RDB$GENERATOR_NAME);
		X.RDB$GENERATOR_ID = generator->gen_id;

		X.RDB$SYSTEM_FLAG = RDB_system;
		X.RDB$SYSTEM_FLAG.NULL = FALSE;

		PAD(ownerName, X.RDB$OWNER_NAME);
		X.RDB$OWNER_NAME.NULL = FALSE;

		PAD(securityClass, X.RDB$SECURITY_CLASS);
		X.RDB$SECURITY_CLASS.NULL = FALSE;

		X.RDB$INITIAL_VALUE = 0;
		X.RDB$INITIAL_VALUE.NULL = FALSE;

		if (generator->gen_description)
		{
		    attachment->storeMetaDataBlob(tdbb, transaction, &X.RDB$DESCRIPTION,
				generator->gen_description);
			X.RDB$DESCRIPTION.NULL = FALSE;
		}
		else
			X.RDB$DESCRIPTION.NULL = TRUE;

		X.RDB$GENERATOR_INCREMENT = 0; // only sys gens have zero default increment
	}
	END_STORE

	security.storePrivileges(tdbb, generator->gen_name, obj_generator);
}


static void store_global_field(thread_db* tdbb, const gfld* gfield,
							   AutoRequest& handle, NonRelationSecurity& security)
{
/**************************************
 *
 *	s t o r e _ g l o b a l _ f i e l d
 *
 **************************************
 *
 * Functional description
 *	Store a global field according to the
 *	passed information.
 *
 **************************************/
	SET_TDBB(tdbb);
	const auto attachment = tdbb->getAttachment();
	const auto transaction = tdbb->getTransaction();

	const auto objName = names[(USHORT)gfield->gfld_name];
	const auto ownerName = security.getOwnerName();

	const auto securityClass = security.storeSecurityClass(tdbb);

	STORE(REQUEST_HANDLE handle TRANSACTION_HANDLE transaction)
		X IN RDB$FIELDS
	{
		PAD(objName, X.RDB$FIELD_NAME);

		X.RDB$FIELD_LENGTH = gfield->gfld_length;
		X.RDB$FIELD_SCALE = 0;

		X.RDB$SYSTEM_FLAG = RDB_system;
		X.RDB$SYSTEM_FLAG.NULL = FALSE;

		PAD(ownerName, X.RDB$OWNER_NAME);
		X.RDB$OWNER_NAME.NULL = FALSE;

		PAD(securityClass, X.RDB$SECURITY_CLASS);
		X.RDB$SECURITY_CLASS.NULL = FALSE;

		X.RDB$FIELD_SUB_TYPE.NULL = TRUE;
		X.RDB$CHARACTER_SET_ID.NULL = TRUE;
		X.RDB$COLLATION_ID.NULL = TRUE;
		X.RDB$SEGMENT_LENGTH.NULL = TRUE;
		X.RDB$CHARACTER_LENGTH.NULL = TRUE;

		if (gfield->gfld_dflt_blr)
		{
		    attachment->storeBinaryBlob(tdbb, transaction, &X.RDB$DEFAULT_VALUE,
				ByteChunk(gfield->gfld_dflt_blr, gfield->gfld_dflt_len));
			X.RDB$DEFAULT_VALUE.NULL = FALSE;
		}
		else
			X.RDB$DEFAULT_VALUE.NULL = TRUE;

		switch (gfield->gfld_dtype)
		{
		case dtype_timestamp:
			X.RDB$FIELD_TYPE = (int) blr_timestamp;
			break;

		case dtype_timestamp_tz:
			X.RDB$FIELD_TYPE = (int) blr_timestamp_tz;
			break;

		case dtype_sql_time:
			X.RDB$FIELD_TYPE = (int) blr_sql_time;
			break;

		case dtype_sql_date:
			X.RDB$FIELD_TYPE = (int) blr_sql_date;
			break;

		case dtype_short:
		case dtype_long:
		case dtype_int64:
			if (gfield->gfld_dtype == dtype_short)
				X.RDB$FIELD_TYPE = (int) blr_short;
			else if (gfield->gfld_dtype == dtype_long)
				X.RDB$FIELD_TYPE = (int) blr_long;
			else
				X.RDB$FIELD_TYPE = (int) blr_int64;

			if ((gfield->gfld_sub_type == dsc_num_type_numeric) ||
				(gfield->gfld_sub_type == dsc_num_type_decimal))
			{
				X.RDB$FIELD_SUB_TYPE.NULL = FALSE;
				X.RDB$FIELD_SUB_TYPE = gfield->gfld_sub_type;
			}
			break;

		case dtype_double:
			X.RDB$FIELD_TYPE = (int) blr_double;
			break;

		case dtype_text:
		case dtype_varying:
			if (gfield->gfld_dtype == dtype_text)
			{
				X.RDB$FIELD_TYPE = (int) blr_text;
			}
			else
			{
				X.RDB$FIELD_TYPE = (int) blr_varying;
			}
			switch (gfield->gfld_sub_type)
			{
			case dsc_text_type_metadata:
				X.RDB$CHARACTER_SET_ID.NULL = FALSE;
				X.RDB$CHARACTER_SET_ID = CS_METADATA;
				X.RDB$COLLATION_ID.NULL = FALSE;
				X.RDB$COLLATION_ID = COLLATE_NONE;
				X.RDB$FIELD_SUB_TYPE.NULL = FALSE;
				X.RDB$FIELD_SUB_TYPE = gfield->gfld_sub_type;
				X.RDB$CHARACTER_LENGTH.NULL = FALSE;
				X.RDB$CHARACTER_LENGTH = X.RDB$FIELD_LENGTH / METADATA_BYTES_PER_CHAR;
				break;
			case dsc_text_type_ascii:
				X.RDB$CHARACTER_SET_ID.NULL = FALSE;
				X.RDB$CHARACTER_SET_ID = CS_ASCII;
				X.RDB$COLLATION_ID.NULL = FALSE;
				X.RDB$COLLATION_ID = COLLATE_NONE;
				X.RDB$FIELD_SUB_TYPE.NULL = FALSE;
				X.RDB$FIELD_SUB_TYPE = gfield->gfld_sub_type;
				break;
			case dsc_text_type_fixed:
				X.RDB$CHARACTER_SET_ID.NULL = FALSE;
				X.RDB$CHARACTER_SET_ID = CS_BINARY;
				X.RDB$COLLATION_ID.NULL = FALSE;
				X.RDB$COLLATION_ID = COLLATE_NONE;
				X.RDB$FIELD_SUB_TYPE.NULL = FALSE;
				X.RDB$FIELD_SUB_TYPE = gfield->gfld_sub_type;
				break;
			default:
				X.RDB$CHARACTER_SET_ID.NULL = FALSE;
				X.RDB$CHARACTER_SET_ID = CS_NONE;
				X.RDB$COLLATION_ID.NULL = FALSE;
				X.RDB$COLLATION_ID = COLLATE_NONE;
				break;
			}
			break;

		case dtype_blob:
			X.RDB$FIELD_TYPE = (int) blr_blob;
			X.RDB$FIELD_SUB_TYPE.NULL = FALSE;
			X.RDB$SEGMENT_LENGTH.NULL = FALSE;
			X.RDB$FIELD_SUB_TYPE = gfield->gfld_sub_type;
			X.RDB$SEGMENT_LENGTH = 80;
			if (gfield->gfld_sub_type == isc_blob_text)
			{
				X.RDB$CHARACTER_SET_ID.NULL = FALSE;
				X.RDB$CHARACTER_SET_ID = CS_METADATA;
			}
			break;

		case dtype_boolean:
			X.RDB$FIELD_TYPE = (int) blr_bool;
			break;

		default:
			fb_assert(FALSE);
			break;
		}

		// Acknowledge not NULL sys fields
		X.RDB$NULL_FLAG.NULL = FALSE;
		X.RDB$NULL_FLAG = !gfield->gfld_nullable;
	}
	END_STORE

	security.storePrivileges(tdbb, objName, obj_field);
}


static void store_indices(thread_db* tdbb, USHORT odsVersion)
{
/**************************************
 *
 *	s t o r e _ i n d i c e s
 *
 **************************************
 *
 * Functional description
 *	Add system indices. If odsVersion is specified, then we are performing
 *	an ODS update, so add only the indices marked as newer than odsVersion.
 *
 **************************************/
	SET_TDBB(tdbb);
	const auto attachment = tdbb->getAttachment();
	const auto transaction = tdbb->getTransaction();

	index_desc idx;

	AutoRequest handle1, handle2, handle3;

	for (int n = 0; n < SYSTEM_INDEX_COUNT; n++)
	{
		const ini_idx_t* index = &indices[n];
		jrd_rel* relation = MET_relation(tdbb, index->ini_idx_relid);

		if (odsVersion && index->ini_idx_ods <= odsVersion)
			continue;

		MetaName indexName;
		indexName.printf("RDB$INDEX_%d", index->ini_idx_index_id);

		STORE(REQUEST_HANDLE handle1 TRANSACTION_HANDLE transaction)
			X IN RDB$INDICES
		{
			PAD(relation->rel_name, X.RDB$RELATION_NAME);
			PAD(indexName, X.RDB$INDEX_NAME);

			X.RDB$UNIQUE_FLAG = index->ini_idx_flags & idx_unique;
			X.RDB$SEGMENT_COUNT = index->ini_idx_segment_count;

			if (index->ini_idx_flags & idx_descending)
			{
				X.RDB$INDEX_TYPE.NULL = FALSE;
				X.RDB$INDEX_TYPE = 1;
			}
			else
				X.RDB$INDEX_TYPE.NULL = TRUE;

			X.RDB$SYSTEM_FLAG = RDB_system;
			X.RDB$SYSTEM_FLAG.NULL = FALSE;

			X.RDB$INDEX_INACTIVE = 0;

			// Store each segment for the index
			index_desc::idx_repeat* tail = idx.idx_rpt;
			for (USHORT position = 0; position < index->ini_idx_segment_count; position++, tail++)
			{
				const auto segment = &index->ini_idx_segment[position];

				STORE(REQUEST_HANDLE handle2 TRANSACTION_HANDLE transaction)
					Y IN RDB$INDEX_SEGMENTS
				{
					jrd_fld* field = (*relation->rel_fields)[segment->ini_idx_rfld_id];

					Y.RDB$FIELD_POSITION = position;
					PAD(X.RDB$INDEX_NAME, Y.RDB$INDEX_NAME);
					PAD(field->fld_name, Y.RDB$FIELD_NAME);
					tail->idx_field = segment->ini_idx_rfld_id;
					tail->idx_itype = segment->ini_idx_type;
				    tail->idx_selectivity = 0;
				}
				END_STORE
			}

			idx.idx_count = index->ini_idx_segment_count;
			idx.idx_flags = index->ini_idx_flags;
			SelectivityList selectivity(*tdbb->getDefaultPool());

			IDX_create_index(tdbb, relation, &idx, indexName.c_str(), NULL,
				transaction, selectivity);

			X.RDB$INDEX_ID = idx.idx_id + 1;
		}
		END_STORE

		if (index->ini_idx_flags & idx_unique)
		{
			STORE(REQUEST_HANDLE handle3 TRANSACTION_HANDLE transaction)
				RC IN RDB$RELATION_CONSTRAINTS
			{
				PAD(indexName, RC.RDB$CONSTRAINT_NAME);
				PAD(indexName, RC.RDB$INDEX_NAME);
				PAD(relation->rel_name, RC.RDB$RELATION_NAME);
				strcpy(RC.RDB$CONSTRAINT_TYPE, UNIQUE_CNSTRT);
				strcpy(RC.RDB$DEFERRABLE, "NO");
				strcpy(RC.RDB$INITIALLY_DEFERRED, "NO");
			}
			END_STORE
		}
	}
}


static void store_intlnames(thread_db* tdbb, NonRelationSecurity& security)
{
/**************************************
 *
 *	s t o r e _ i n t l n a m e s
 *
 **************************************
 *
 * Functional description
 *	Store symbolic names & information for international
 *	character sets & collations.
 *
 **************************************/
	SET_TDBB(tdbb);
	const auto attachment = tdbb->getAttachment();
	const auto transaction = tdbb->getTransaction();

	const auto ownerName = security.getOwnerName();

	AutoRequest handle;

	for (const IntlManager::CharSetDefinition* charSet = IntlManager::defaultCharSets;
		 charSet->name; ++charSet)
	{
		const auto securityClass = security.storeSecurityClass(tdbb);

		STORE(REQUEST_HANDLE handle TRANSACTION_HANDLE transaction)
			X IN RDB$CHARACTER_SETS USING
		{
			PAD(charSet->name, X.RDB$CHARACTER_SET_NAME);
			PAD(charSet->name, X.RDB$DEFAULT_COLLATE_NAME);
			X.RDB$CHARACTER_SET_ID = charSet->id;

			X.RDB$BYTES_PER_CHARACTER = charSet->maxBytes;

			X.RDB$SYSTEM_FLAG = RDB_system;
			X.RDB$SYSTEM_FLAG.NULL = FALSE;

			PAD(ownerName, X.RDB$OWNER_NAME);
			X.RDB$OWNER_NAME.NULL = FALSE;

			PAD(securityClass, X.RDB$SECURITY_CLASS);
			X.RDB$SECURITY_CLASS.NULL = FALSE;
		}
		END_STORE

		security.storePrivileges(tdbb, charSet->name, obj_charset);
	}

	handle.reset();

	for (const IntlManager::CollationDefinition* collation = IntlManager::defaultCollations;
		collation->name; ++collation)
	{
		const auto securityClass = security.storeSecurityClass(tdbb);

		STORE(REQUEST_HANDLE handle TRANSACTION_HANDLE transaction)
			X IN RDB$COLLATIONS USING
		{
			PAD(collation->name, X.RDB$COLLATION_NAME);

			if (collation->baseName)
			{
				X.RDB$BASE_COLLATION_NAME.NULL = false;
				PAD(collation->baseName, X.RDB$BASE_COLLATION_NAME);
			}
			else
				X.RDB$BASE_COLLATION_NAME.NULL = true;

			X.RDB$CHARACTER_SET_ID = collation->charSetId;
			X.RDB$COLLATION_ID = collation->collationId;

			X.RDB$SYSTEM_FLAG = RDB_system;
			X.RDB$SYSTEM_FLAG.NULL = FALSE;

			PAD(ownerName, X.RDB$OWNER_NAME);
			X.RDB$OWNER_NAME.NULL = FALSE;

			PAD(securityClass, X.RDB$SECURITY_CLASS);
			X.RDB$SECURITY_CLASS.NULL = FALSE;

			X.RDB$COLLATION_ATTRIBUTES = collation->attributes;

			if (collation->specificAttributes)
			{
				attachment->storeMetaDataBlob(tdbb, transaction,
					&X.RDB$SPECIFIC_ATTRIBUTES, collation->specificAttributes);
				X.RDB$SPECIFIC_ATTRIBUTES.NULL = FALSE;
			}
			else
				X.RDB$SPECIFIC_ATTRIBUTES.NULL = TRUE;
		}
		END_STORE

		security.storePrivileges(tdbb, collation->name, obj_collation);
	}
}


static void store_message(thread_db* tdbb, const trigger_msg* message, AutoRequest& handle)
{
/**************************************
 *
 *	s t o r e _ m e s s a g e
 *
 **************************************
 *
 * Functional description
 *	Store system trigger messages.
 *
 **************************************/
	SET_TDBB(tdbb);
	const auto attachment = tdbb->getAttachment();
	const auto transaction = tdbb->getTransaction();

	// store the trigger

	STORE(REQUEST_HANDLE handle TRANSACTION_HANDLE transaction)
		X IN RDB$TRIGGER_MESSAGES
	{
		PAD(message->trigmsg_name, X.RDB$TRIGGER_NAME);
		X.RDB$MESSAGE_NUMBER = message->trigmsg_number;
		PAD(message->trigmsg_text, X.RDB$MESSAGE);
	}
	END_STORE
}


static void store_relation(thread_db* tdbb,
						   int relId,
						   const char* relName,
						   int fieldId,
						   int relType,
						   AutoRequest& handle,
						   RelationSecurity& security)
{
	SET_TDBB(tdbb);
	const auto attachment = tdbb->getAttachment();
	const auto transaction = tdbb->getTransaction();

	const auto ownerName = security.getOwnerName();

	MetaName securityClass, defaultClass;
	security.storeSecurityClass(tdbb, securityClass, defaultClass);

	STORE(REQUEST_HANDLE handle TRANSACTION_HANDLE transaction)
		X IN RDB$RELATIONS
	{
		X.RDB$RELATION_ID = relId;
		PAD(relName, X.RDB$RELATION_NAME);

		PAD(ownerName, X.RDB$OWNER_NAME);
		X.RDB$OWNER_NAME.NULL = FALSE;

		PAD(securityClass, X.RDB$SECURITY_CLASS);
		X.RDB$SECURITY_CLASS.NULL = FALSE;

		PAD(defaultClass, X.RDB$DEFAULT_CLASS);
		X.RDB$DEFAULT_CLASS.NULL = FALSE;

		X.RDB$FIELD_ID = fieldId;
		X.RDB$FORMAT = 0;
		X.RDB$SYSTEM_FLAG = RDB_system;
		X.RDB$DBKEY_LENGTH = 8;
	}
	END_STORE;

	security.storePrivileges(tdbb, relName);
}

static void store_relation_field(thread_db* tdbb,
								 int fieldId,
								 const char* relName,
								 const char* fieldName,
								 const char* globalName,
								 int updateFlag,
								 AutoRequest& handle)
{
/**************************************
 *
 *	s t o r e _ r e l a t i o n _ f i e l d
 *
 **************************************
 *
 * Functional description
 *	Store a local field according to the
 *	passed information.
 *
 **************************************/
	SET_TDBB(tdbb);
	const auto attachment = tdbb->getAttachment();
	const auto transaction = tdbb->getTransaction();

	STORE(REQUEST_HANDLE handle TRANSACTION_HANDLE transaction)
		X IN RDB$RELATION_FIELDS
	{
		PAD(relName, X.RDB$RELATION_NAME);
		PAD(fieldName, X.RDB$FIELD_NAME);
		PAD(globalName, X.RDB$FIELD_SOURCE);
		X.RDB$FIELD_POSITION = fieldId;
		X.RDB$FIELD_ID = fieldId;
		X.RDB$SYSTEM_FLAG = RDB_system;
		X.RDB$SYSTEM_FLAG.NULL = FALSE;
		X.RDB$UPDATE_FLAG = updateFlag;
	}
	END_STORE
}


// Store system packages.
static void store_packages(thread_db* tdbb, NonRelationSecurity& security, USHORT odsVersion)
{
	SET_TDBB(tdbb);
	const auto dbb = tdbb->getDatabase();
	const auto attachment = tdbb->getAttachment();
	const auto transaction = tdbb->getTransaction();

	const auto ownerName = security.getOwnerName();

	AutoRequest packageHandle, procedureHandle, procedureParameterHandle;
	AutoRequest functionHandle, functionReturnHandle, functionArgumentHandle;
	const SLONG procGen = lookupGenerator(PROCEDURES_GENERATOR);
	const SLONG funcGen = lookupGenerator(FUNCTIONS_GENERATOR);

	for (auto& systemPackage : SystemPackage::get())
	{
		if (odsVersion && systemPackage.odsVersion <= odsVersion)
			continue;

		const auto securityClass = security.storeSecurityClass(tdbb);

		STORE (REQUEST_HANDLE packageHandle TRANSACTION_HANDLE transaction)
			PKG IN RDB$PACKAGES
		{
			PAD(systemPackage.name, PKG.RDB$PACKAGE_NAME);

			PAD(ownerName, PKG.RDB$OWNER_NAME);
			PKG.RDB$OWNER_NAME.NULL = FALSE;

			PAD(securityClass, PKG.RDB$SECURITY_CLASS);
			PKG.RDB$SECURITY_CLASS.NULL = FALSE;

			PKG.RDB$SYSTEM_FLAG = RDB_system;
			PKG.RDB$VALID_BODY_FLAG = TRUE;
		}
		END_STORE

		security.storePrivileges(tdbb, systemPackage.name, obj_package_header);

		for (auto& procedure : systemPackage.procedures)
		{
			STORE (REQUEST_HANDLE procedureHandle TRANSACTION_HANDLE transaction)
				PRC IN RDB$PROCEDURES
			{
				PAD(systemPackage.name, PRC.RDB$PACKAGE_NAME);
				PAD(procedure.name, PRC.RDB$PROCEDURE_NAME);

				PAD(ownerName, PRC.RDB$OWNER_NAME);
				PRC.RDB$SYSTEM_FLAG = RDB_system;

				PRC.RDB$PROCEDURE_ID = DPM_gen_id(tdbb, procGen, false, 1);

				PRC.RDB$PROCEDURE_INPUTS = (SSHORT) procedure.inputParameters.getCount();
				PRC.RDB$PROCEDURE_OUTPUTS = (SSHORT) procedure.outputParameters.getCount();
				PRC.RDB$PROCEDURE_TYPE = (SSHORT) procedure.type;
				PRC.RDB$PRIVATE_FLAG = FALSE;
				PRC.RDB$VALID_BLR = TRUE;
				PAD("SYSTEM", PRC.RDB$ENGINE_NAME);
			}
			END_STORE

			for (SSHORT parameterType = 0; parameterType <= 1; ++parameterType)
			{
				SSHORT paramNumber = -1;

				for (auto& parameter : parameterType == 0 ? procedure.inputParameters : procedure.outputParameters)
				{
					++paramNumber;

					STORE (REQUEST_HANDLE procedureParameterHandle TRANSACTION_HANDLE transaction)
						PP IN RDB$PROCEDURE_PARAMETERS
					{
						PAD(systemPackage.name, PP.RDB$PACKAGE_NAME);
						PAD(procedure.name, PP.RDB$PROCEDURE_NAME);
						PAD(parameter.name, PP.RDB$PARAMETER_NAME);

						PP.RDB$SYSTEM_FLAG = RDB_system;

						PP.RDB$PARAMETER_NUMBER = paramNumber;
						PP.RDB$PARAMETER_TYPE = parameterType;
						PP.RDB$PARAMETER_MECHANISM = (SSHORT) prm_mech_normal;
						PP.RDB$NULL_FLAG = !parameter.nullable;

						PAD(names[gfields[parameter.fieldId].gfld_name], PP.RDB$FIELD_SOURCE);

						fb_assert(parameter.defaultBlr.isEmpty() == !parameter.defaultText);

						if (parameter.defaultBlr.hasData())
						{
							attachment->storeMetaDataBlob(tdbb, transaction, &PP.RDB$DEFAULT_SOURCE,
								string("default ") + parameter.defaultText);
							PP.RDB$DEFAULT_SOURCE.NULL = FALSE;

							Array<UCHAR> blrData(1 + parameter.defaultBlr.getCount() + 1);
							blrData.push(blr_version5);
							blrData.append(parameter.defaultBlr);
							blrData.push(blr_eoc);

							attachment->storeBinaryBlob(tdbb, transaction, &PP.RDB$DEFAULT_VALUE,
								blrData);
							PP.RDB$DEFAULT_VALUE.NULL = FALSE;
						}
						else
						{
							PP.RDB$DEFAULT_SOURCE.NULL = TRUE;
							PP.RDB$DEFAULT_VALUE.NULL = TRUE;
						}
					}
					END_STORE
				}
			}
		}

		for (auto& function : systemPackage.functions)
		{
			STORE (REQUEST_HANDLE functionHandle TRANSACTION_HANDLE transaction)
				FUN IN RDB$FUNCTIONS
			{
				PAD(systemPackage.name, FUN.RDB$PACKAGE_NAME);
				PAD(function.name, FUN.RDB$FUNCTION_NAME);

				PAD(ownerName, FUN.RDB$OWNER_NAME);
				FUN.RDB$SYSTEM_FLAG = RDB_system;

				FUN.RDB$FUNCTION_ID = DPM_gen_id(tdbb, funcGen, false, 1);

				FUN.RDB$RETURN_ARGUMENT = 0;
				FUN.RDB$PRIVATE_FLAG = FALSE;
				FUN.RDB$VALID_BLR = TRUE;
				PAD("SYSTEM", FUN.RDB$ENGINE_NAME);
			}
			END_STORE

			SSHORT paramNumber = 0;

			STORE (REQUEST_HANDLE functionReturnHandle TRANSACTION_HANDLE transaction)
				ARG IN RDB$FUNCTION_ARGUMENTS
			{
				PAD(systemPackage.name, ARG.RDB$PACKAGE_NAME);
				PAD(function.name, ARG.RDB$FUNCTION_NAME);

				ARG.RDB$SYSTEM_FLAG = RDB_system;

				ARG.RDB$ARGUMENT_POSITION = paramNumber;
				ARG.RDB$NULL_FLAG = !function.returnType.nullable;

				PAD(names[gfields[function.returnType.fieldId].gfld_name], ARG.RDB$FIELD_SOURCE);
			}
			END_STORE

			for (auto& parameter : function.parameters)
			{
				++paramNumber;

				STORE (REQUEST_HANDLE functionArgumentHandle TRANSACTION_HANDLE transaction)
					ARG IN RDB$FUNCTION_ARGUMENTS
				{
					PAD(systemPackage.name, ARG.RDB$PACKAGE_NAME);
					PAD(function.name, ARG.RDB$FUNCTION_NAME);
					PAD(parameter.name, ARG.RDB$ARGUMENT_NAME);

					ARG.RDB$SYSTEM_FLAG = RDB_system;

					ARG.RDB$ARGUMENT_POSITION = paramNumber;
					ARG.RDB$NULL_FLAG = !parameter.nullable;

					PAD(names[gfields[parameter.fieldId].gfld_name], ARG.RDB$FIELD_SOURCE);

					fb_assert(parameter.defaultBlr.isEmpty() == !parameter.defaultText);

					if (parameter.defaultBlr.hasData())
					{
						attachment->storeMetaDataBlob(tdbb, transaction, &ARG.RDB$DEFAULT_SOURCE,
							string("default ") + parameter.defaultText);
						ARG.RDB$DEFAULT_SOURCE.NULL = FALSE;

						Array<UCHAR> blrData(1 + parameter.defaultBlr.getCount() + 1);
						blrData.push(blr_version5);
						blrData.append(parameter.defaultBlr);
						blrData.push(blr_eoc);

						attachment->storeBinaryBlob(tdbb, transaction, &ARG.RDB$DEFAULT_VALUE,
							blrData);
						ARG.RDB$DEFAULT_VALUE.NULL = FALSE;
					}
					else
					{
						ARG.RDB$DEFAULT_SOURCE.NULL = TRUE;
						ARG.RDB$DEFAULT_VALUE.NULL = TRUE;
					}
				}
				END_STORE
			}
		}
	}
}


static void store_trigger(thread_db* tdbb, const jrd_trg* trigger, AutoRequest& handle)
{
/**************************************
 *
 *	s t o r e _ t r i g g e r
 *
 **************************************
 *
 * Functional description
 *	Store the trigger according to the
 *	information in the trigger block.
 *
 **************************************/
	SET_TDBB(tdbb);
	const auto attachment = tdbb->getAttachment();
	const auto transaction = tdbb->getTransaction();

	// indicate that the relation format needs revising
	dsc desc;
	desc.makeText(static_cast<USHORT>(strlen(names[trigger->trg_relation])), CS_METADATA,
		(UCHAR*) names[trigger->trg_relation]);
	DFW_post_system_work(tdbb, dfw_update_format, &desc, 0);

	// store the trigger

	STORE(REQUEST_HANDLE handle TRANSACTION_HANDLE transaction)
		X IN RDB$TRIGGERS
	{
		PAD(trigger->trg_name, X.RDB$TRIGGER_NAME);
		PAD(names[trigger->trg_relation], X.RDB$RELATION_NAME);
		X.RDB$TRIGGER_SEQUENCE = 0;
		X.RDB$SYSTEM_FLAG = RDB_system;
		X.RDB$SYSTEM_FLAG.NULL = FALSE;
		X.RDB$TRIGGER_TYPE = trigger->trg_type;
		X.RDB$FLAGS = trigger->trg_flags;
		attachment->storeBinaryBlob(tdbb, transaction, &X.RDB$TRIGGER_BLR,
			ByteChunk(trigger->trg_blr, trigger->trg_length));
	}
	END_STORE
}
